/**
 * 
 */
package org.ligo.core.resolvers.impl;

import static java.util.Collections.*;
import static org.ligo.core.utils.Constants.*;
import static org.ligo.data.impl.DataBuilders.*;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.namespace.QName;

import org.ligo.core.resolvers.api.ExpressionResolver;
import org.ligo.data.LigoData;
import org.ligo.data.LigoObject;
import org.ligo.data.LigoValue;
import org.ligo.data.impl.NamedData;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * An {@link ExpressionResolver} for binding expressions generated by the following grammar:
 * <p>
 * <ul> 
 * <li>
 * <em>name</em> = <tt>n</tt> | <tt>(n)</tt>
 * <li>
 * <em>path</em> = <em>name</em>  | <em>path</em><tt>/</tt><em>exp</em>
 * <li>
 * <em>exp</em> = <em>exp</em><tt>[</tt><em>exp</em><tt>]</tt> | <em>path</em>
 * </ul>
 * 
 * where <tt>n</tt> ranges over an infinite set of <em>names</em>. Expressions are resolved with respect to an instance of {@link LigoData} as follows:
 * 
 * <p>
 * 
 * <ul>
 * <li> if the instance is a {@link LigoValue}, an expression resolves to the empty set;
 * <li> <tt>n</tt> resolves to the <tt>n</tt>-items of the instance.
 * <br>For example, <tt>a</tt> resolves to all the <tt>a</tt>-items of the instance; 
 * <li> <tt>(n)</tt> resolves to the items of the instance whose name matches <tt>n</tt> as a regular expression;
 * <br>For example, <tt>(^a.*z$)</tt> resolves to all the items of the instance whose name begins with <tt>a</tt> and terminates with <tt>z</tt>;
 * <li> <em>path</em><tt>/</tt><em>exp</em> resolves to the instances obtained by resolving <em>exp</em> with respect to all the instances
 * which <em>path</em> resolves to.
 * <br>For example, <tt>a/b</tt> resolves to all the <tt>b</tt>-items of <tt>a</tt>-items of the instance;
 * <li>  <em>exp1</em><tt>[</tt><em>exp2</em><tt>]</tt> resolves to a set of {@link LigoObject}s, where each
 * object has unnamed items for each of the instances which <em>exp2</em> resolves to with respect to some
 * instance which <em>exp1</em> resolves to.
 * <br>For example, <tt>a[b]</tt> resolves to objects with unnamed parts for all the <tt>b</tt>-items of some <tt>a</tt>-item of the instance.
 * Expressions of this kinds are called <em>collecting expression</em>, as the objects they resolve to model collections. Thus, <tt>a[b]</tt>
 * resolves to collections of all <tt>b</tt>-items below any given <tt>a</tt> of the instance.
 * </ul>
 * 
 * As a convenience, the resolver will resolve:
 * 
 * <ul>
 * 	<li><em>exp</em><tt>[]</tt> as the expression <em>exp</em><tt>[(.*)]</tt>;
 * 	<li><tt>[</tt><em>exp</em><tt>]</tt> as the expression <tt>(.*)[</tt><em>exp</em><tt>]</tt>
 * <li><tt>[]</tt> as the expression <tt>(.*)[(.*)]</tt>
 * </ul>
 * 
 * @author Fabio Simeoni
 *
 */
public class LigoExpressionResolver implements ExpressionResolver {

	private static final Logger logger = LoggerFactory.getLogger(LigoExpressionResolver.class);
	
	static final Pattern COLLEXP_PATTERN = Pattern.compile("^([^\\[]*)\\[(.*)\\]$");
	static final Pattern PATHEXP_PATTERN = Pattern.compile("^([^/\\[]+)$|^([^/\\[]+)/(.+)$");
	static final Pattern REGEXP_PATTERN = Pattern.compile("^\\((.*)\\)$");
	static final String INVALID_EXPRESSION_ERROR = "malformed expression %1";
	static final String COLLNODE_CREATION_LOG = "converted {} into collection node {}";

	private static final QName emptyExp = new QName("");
	
	/**{@inheritDoc}*/
	@Override
	public List<? extends LigoData> resolve(QName exp, LigoData data) {
		
		String unqualified = exp.getLocalPart();
		
		//is it a coll expression?
		Matcher m = COLLEXP_PATTERN.matcher(unqualified);
		
		if (m.matches()) {
			QName collExp = new QName(exp.getNamespaceURI(),m.group(1));
			QName elementExp = new QName(exp.getNamespaceURI(),m.group(2));
			return resolveCollection(collExp,elementExp, data);
		
		}
		// is it a path expression
		m= PATHEXP_PATTERN.matcher(unqualified);
		if (m.matches())
			//is it a plain name?
			if (m.group(1)!=null)
				return resolvePath(exp,emptyExp,data);
			//it is a full path
			else {//path case
				QName name = new QName(exp.getNamespaceURI(),m.group(2));
				QName rest = new QName(exp.getNamespaceURI(),m.group(3));
				return resolvePath(name,rest,data);
			}
				
		//it is an malformed expression
		throw new RuntimeException(String.format(INVALID_EXPRESSION_ERROR,unqualified));
	}
	
	
	
	List<? extends LigoData> resolveCollection(QName collExp, QName elementExp, LigoData data) {
		
		if (collExp.getLocalPart().isEmpty())
			collExp = new QName(collExp.getNamespaceURI(),"(.*)");
		
		if (elementExp.getLocalPart().isEmpty())
			elementExp = new QName(elementExp.getNamespaceURI(),"(.*)");
		
		List<LigoData> resolved = new ArrayList<LigoData>();
		
		for (LigoData match : matchLabel(collExp,data)) {
			
			List<NamedData> elements = new ArrayList<NamedData>();
			//System.out.println("resolving "+elementPath+" on "+match);
			for (LigoData el : resolve(elementExp,match))
				elements.add(n(NONAME,el));
			
			if (!elements.isEmpty()) {
				LigoObject collection = o(elements.toArray(new NamedData[0])); 
				
				resolved.add(collection);
				
				logger.trace(COLLNODE_CREATION_LOG,match,collection);
			}
		}
		
		return resolved;
		
	}
	
	List<? extends LigoData> resolvePath(QName name, QName rest, LigoData data) {
		
		List<LigoData> matches =  matchLabel(name,data);
		
		if (rest.getLocalPart().isEmpty())
			return matches;
		
		List<LigoData> resolved = new ArrayList<LigoData>();
		
		for (LigoData match :matches)
			resolved.addAll(resolve(rest,match)); 
		
		return resolved;
		
		
		
	}
	
	List<LigoData> matchLabel(QName name, LigoData data) {
		
		if (data instanceof LigoValue)
			return emptyList();
		
		LigoObject object = (LigoObject) data;
		
		List<LigoData> matches = new ArrayList<LigoData>();
		
		
		String unqualified = name.getLocalPart();
			
		Matcher matcher = REGEXP_PATTERN.matcher(unqualified);
		
		if (matcher.matches()) {//regexp case
			String regexp = matcher.group(1);
			for (QName n : object.names())
				if (n.getNamespaceURI().equals(name.getNamespaceURI()) && n.getLocalPart().matches(regexp))
					matches.addAll(object.data(n));
		}
		else 
			matches = object.data(name);

		return matches;
	}


}
